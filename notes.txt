#Tracking your files

--Each file in your  working directory can be in one of the two states: tracked and untracked

--Trcaked files are files that Git knows about.
--Any file in your working directory that was not in your last snapshot and is not in your staging area is untracked files.

#below are the commands how to add file or how to stage file.

--for specific file
git add <file-name>

--for all files and folder
git add . (here dot always refers to current directory)


#commit changes

--moving files from stage area to the git folder is called commit.
--making commits, creates version/snapshots of your projects.

--committing changes
git commit -m "your commit message"
  here -m is flag which stands for message.


#Lifecycle of the status of a file:

untracked --> unmodified  --> modified  --> stage

if you do commit to staged file,it becomes unmodified.

Note: once you have made some changes to the file, make sure to add that file again to stage area otherwise commit would not happen. Git 
      will not able to understand the changes you have made to that file.


#git logging

--viewing the commit history
   git log

 The most recent commit will at the top.

  git log -oneline

#Deleting a git project:
 rm -rf .git


#Additional git commands

--skipping the staging area
  git commit -a -m "commit message"

--git diff
 if you want to know exactly what you have changed, not just which files were changed - you can use the "git diff" command.

 Note: once you staged your file, you won't be able to see diffrence between previous commit and current change.

 if you want to see the changes that you have staged just right now and commits that was already there in the previous one, you can use 
 below command.
  git diff --staged

#.gitignore
---------------
often times, you donot want git to track of some specific autogenerated files like logs or build files etc.
To avoid them, you can list files or pattern for files in .gitignore file.

#moving and removing files
--------------------------
So when you delete or move a file using git as a tool, then it also stages the changes. So whatever the changes you do, it will automatically
get stages. So you don't have to stage the changes.means we don't have to explicitely add into staging area.
   
   -git rm <file-name>
   -git mv <location-of-source-filename> <destination-of-source-filename>

 Here are some points to note:
- if you run "rm <file-name>" command, file will get deleted but those changes yet to be identified by git so you have to explicitely 
  tell git in the stage. In simple words, those changes won't be available in staging area.

- if you run "git rm -rf <file-name>" command, those changes will automatically reflected in staging area. no need to run" git add ." 
  command.

#Untrack an already tracked file
 -git rm --cached <file-name>

Note: git doesn't keep track of empty folder.

#unstaging and unmodifying files:
--------------------------------
 -git restore --unstaged <file-name> 

 -git checkout -- <filename>
  this command will takes your file to last version/commit.
  Note: When files are modified and not commited then only you can only run above command.

  -git checkout -f 
  it will rollback to the previous commit. loosing all newly modified files.


#setiing alias
-git config --global alias.st status

  it will put alias of status as st.


#Non linear development
--------------------------

  #Branching
  -------------
  what is branching?
  -A branch is simply a lightweight moveable pointer to one of the commits. The default branch name in git is master.
  - branching : diverging from the main branch.
   
  why branching is required?
  -------------------------
  suppose two diffrent person working on third party project.In that case, third party would not allow them to directly commit code in 
  master branch. so in that case, they gonna create branch from the master branch and after that they can make start working. but code
  will not reflect into the master branch. for that third party have to merge the branch.

  Creating new branch:
  --------------------
  Always remember head goes to the last commit.

  To see branch:
   -git branch
  
  To see last commit to branch
   -git branch -v

  to create a new branch:
   - git branch <branch-name>

  Switching to branches:
  ----------------------
  moving between branches:
  * shows in which branch currently I am in.

  checkout an existing branch:
   - git checkout <branch-name>
   When you write checkout, checkout takes you to the existing branch.

   When you run "git log", you will see head is pointing to development branch.
   press "q" to come out of it.

   creating and checkout new branch:
  ----------------------------------
    - git checkout -b <branch-name>

    Here '-b' says that create a new branch and directly go to that branch.


#working with branching:
------------------------
Whatever changes you make in development branch,it won't show in master branch unless it is merged. Once branch is created at certain 
point of commits on master branch, development branch can only see files or changes upto that commit. After that whatever changes made 
on master branch, won't be shown in development branch.

#branch logging:
------------------
Suppose you have made some changes in development branch and you want to switch into diffrent branch without commiting it, you won't be
able to do that. You have to save it and commit it before switching into diffrent branch.

--git log --oneline --graph --all
this command shows all the branches in a pictorial representation like a tree because we have non-linear development.


#Deleting branch:
--------------------
deleting a merged branch:
 - git branch -d <branch-name>

deleting a non-merged branch:
 - git branch -D <branch-name>



#Non linear development: Merging
--------------------------------------
so to merge any branch, run below git command from master branch:
 -git merge <branch-name-you-want-to-merge>

this will update the master branch successfully.




#Merge conflicts:
----------------------
changes in a file made by 2 diffrent branches, trying to get merge results in a merge conflicts.



#Git branching workflow in production:
----------------------------------------
Long running branches:
  -master
  -development

Topic branches:(also known as short term branches)
  -Authentication
  -UI changes

#Rebasing:
--------------
Integrate changes from one branch into another.
The eventual outcome would be same as merging, but the process of integrating the changes are diffrent.




 
